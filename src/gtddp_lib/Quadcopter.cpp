
#include <eigen3/Eigen/Dense>
#include <iostream>
#include <cmath>

#include "gtddp_drone/gtddp_lib/Quadcopter.h"

using namespace Eigen;
using namespace Constants;
using namespace std;
using namespace boost::numeric::odeint;


/**
 Dynamics_mm is the main ode function to solve dx/dt = f(x,u,v).
 @param x -  a num_states x 1 VectorXd of state values
 @param u_ - a num_controls x 1 VectorXd of stabilizing controls
 @param v_ - a num_controls x 1 VectorXd of destabilizing controls
 @return updated x - a num_states x 1 VectorXd of updated state
 */
void Quadcopter::dynamics_mm(const Eigen::VectorXd& x , Eigen::VectorXd& dxdt,  double t)
{
    double x6=x(6);
    double x7=x(7);
    double x8=x(8);
    double x9=x(9);
    double x10=x(10);
    double x11=x(11);
    
    double sin_phi = sin(x6);
    double cos_phi = cos(x6);
    
    double sin_theta = sin(x7);
    double cos_theta = cos(x7);
    double tan_theta = tan(x7);
    double sec_theta = 1/cos_theta;
    
    double sin_psi = sin(x8);
    double cos_psi = cos(x8);
    
    double u0 = ui_(0); //Force
    double u1 = ui_(1); //Torque 1
    double u2 = ui_(2); //Torque 2
    double u3 = ui_(3); //Torque 3
    
    double v0 = vi_(0);
    double v1 = vi_(1);
    double v2 = vi_(2);
    double v3 = vi_(3);

    //Declare dynamics matrices and vectors
    Eigen::Vector3d force_vector(0, 0, 0);              //force vector
    Eigen::Matrix3d I_matrix;                           //inertia matrix
    Eigen::Matrix3d phi_matrix;                         //matrix for finding roll, pitch, and yaw
    Eigen::Vector3d pqr_vector(x(9), x(10), x(11));     //make a vector for [p, q, r]
    Eigen::Matrix3d R_matrix;                           //rotation matrix
    Eigen::Vector3d torque_vector(u1, u2, u3);          //vector of 3 input torques

    //Make that big R matrix that has a lot of trig in it
    R_matrix(0, 0) = (cos_psi * cos_theta) - (sin_phi * sin_psi * sin_theta);
    R_matrix(0, 1) = -cos_phi * sin_psi;
    R_matrix(0, 2) = (cos_psi * sin_theta) + (cos_theta * sin_phi * sin_psi);
    R_matrix(1, 0) = (cos_theta * sin_psi) + (cos_psi * sin_phi * sin_theta);
    R_matrix(1, 1) = cos_phi * cos_psi;
    R_matrix(1, 2) = (sin_psi * sin_theta) - (cos_psi * cos_theta * sin_theta);
    R_matrix(2, 0) = -cos_phi * sin_theta;
    R_matrix(2, 1) = sin_phi;
    R_matrix(2, 2) = cos_phi * cos_theta;

    //Fill out the values for the phi matrix
    phi_matrix(0, 0) = cos_theta;
    phi_matrix(0, 2) = -cos_phi * sin_theta;
    phi_matrix(1, 1) = 1;
    phi_matrix(1, 2) = sin_phi;
    phi_matrix(2, 0) = sin_theta;
    phi_matrix(2, 2) = cos_phi * cos_theta;

    //Find the Inertia matrix
    I_matrix(0, 0) = Ixx;
    I_matrix(1, 1) = Iyy;
    I_matrix(2, 2) = Izz;
   
    //Find the force vector generated by u0
    force_vector(2, 0) = u0 / m; //TODO: include v0


    /* Dynamics Calculations */
    VectorXd dx(num_states);    //shallow copy
    dx.setZero();

    //The 0-2 elements in dx are linear accelerations
    dx(0) = x(3);
    dx(1) = x(4);
    dx(2) = x(5);

    //Invert the phi matrix and find the 3-5 elements in dx
    dx.block<3, 1>(3, 0) = phi_matrix.inverse() * pqr_vector;

    //Find elements 6-8 in dx, and subtract gravity from 8
    dx.block<3, 1>(6, 0) = R_matrix * force_vector;
    dx(8) -= grav;

    //Calculate the 9-11 block
    dx.block<3, 1>(9, 0) = (I_matrix.inverse() * torque_vector) - (pqr_vector.cross(I_matrix * pqr_vector));

    //Set the dynamics
    dxdt=dx;
}

/**
 forward_propagate_mm calls ode object dynamics_mm at each iteration to propagate
 dynamics given u_traj, v_traj
 @param u_traj_ - a num_controls x 1 VectorXd of stabilizing controls
 @param v_traj - a num_controls x 1 VectorXd of destabilizing controls
 @update x_traj - update x_traj
 */
void Quadcopter::forward_propagate_mm(vector<VectorXd>& x_traj, const vector<VectorXd>& u_traj, const vector<VectorXd>& v_traj)
{
    // initial condition
    VectorXd x= x_traj[0];
    double t=0;
    // main integration loop : propagation over time step
    for (int i = 0; i < num_time_steps-1; i++) {
       //update current inputs
        ui_=u_traj[i];
        vi_=v_traj[i];
        
        using namespace std::placeholders;
        stepper.do_step(std::bind(&::Quadcopter::dynamics_mm, this, _1, _2, _3), x, t, dt);
        t += dt;
        x_traj[i+1] = x; //save x trajectory
        t += dt;
    } //for num_time_steps-1
    
} //forward_propagate_mm


void Quadcopter::feedforward_controls(VectorXd current_state, const vector<VectorXd>& u_traj, const vector<MatrixXd>& K_traj, vector<VectorXd>& x_traj)
{
    // initial condition
    VectorXd x = current_state;
    VectorXd v_zero(4);
    v_zero << 0, 0, 0, 0;

    double t=0;
    // main integration loop : propagation over time step
    for (int i = 0; i < x_traj.size() - 1; i++) {
       //update current inputs
        ui_ = u_traj[i] + K_traj[i] * (x - x_traj[i]);
        vi_ = v_zero;
        
        using namespace std::placeholders;
        stepper.do_step(std::bind(&::Quadcopter::dynamics_mm, this, _1, _2, _3), x, t, dt);
        t += dt;
        x_traj[i+1] = x; //save x trajectory
        t += dt;
    } //for num_time_steps-1
    
} //forward_propagate_mm


/**
 linearize_dynamics_mm obtains the gradient of f (A,B,C) at the given trajectory
 @param x_traj -  a num_states x 1 VectorXd of state values
 @param u_traj_ - a num_controls x 1 VectorXd of stabilizing controls
 @param v_traj - a num_controls x 1 VectorXd of destabilizing controls
 @return A,B,C - gradient Matrix Fx Fu Fv
 */
void Quadcopter::linearize_dynamics_mm(const vector<VectorXd>& x_traj, const vector<VectorXd>& u_traj, const vector<VectorXd>& v_traj,
                                      vector<MatrixXd>& A,vector<MatrixXd>& B,vector<MatrixXd>& C){
    
    for (int i=0; i < (num_time_steps - 1); i++)
    {
        double x6=x_traj[i](6);
        double x7=x_traj[i](7);
        double x8=x_traj[i](8);
        double x9=x_traj[i](9);
        double x10=x_traj[i](10);
        double x11=x_traj[i](11);
        
        double sin_phi = sin(x6);
        double cos_phi = cos(x6);
        double tan_phi = tan(x6);
        double sec_phi = 1 / cos_phi;
        
        double sin_theta = sin(x7);
        double cos_theta = cos(x7);
        double tan_theta = tan(x7);
        double sec_theta = 1 / cos_theta;
        
        double sin_psi = sin(x8);
        double cos_psi = cos(x8);
        
        double u0 = u_traj[i](0);
        double v0 = v_traj[i](0);

        MatrixXd A_sec;
        MatrixXd B_sec;
        MatrixXd C_sec;
        A_sec.setZero(num_states,num_states);
        B_sec.setZero(num_states,num_controls_u);
        C_sec.setZero(num_states,num_controls_v);
        
        //3 <-> 6
        //4 <-> 7
        //5 <-> 8

        /* Find the gradient of the Quadcopter dynamics using a jacobian */

        //xyz relate linearly with velocity
        A_sec(0,3)=1;
        A_sec(1,4)=1;
        A_sec(2,5)=1;

        //dx(3) relates with theta (4), p (9), and r (11)
        A_sec(3, 4) = (-sin_theta * x9) + (cos_theta * x11);            //df3 / d(theta)
        A_sec(3, 9) = (-sin_theta);                                     //df3 / d(p)
        A_sec(3, 11) = (cos_theta);                                     //df3 / d(r)

        //dx(4) relates with phi (3), theta (4), p (9), q (10), and r (11)
        A_sec(4, 3) = x9 * sin_theta * pow((1 / cos_phi), 2);           //df4 / d(phi)
        A_sec(4, 4) = (cos_theta * x9 * tan_phi) + (-sin_theta * x11);  //df4 / d(theta)
        A_sec(4, 9) = (sin_theta * tan_phi);                            //df4 / d(p)
        A_sec(4, 10) = 1;                                               //df4 / d(q)
        A_sec(4, 11) = (cos_theta);                                     //df4 / d(r)

        //dx(5) relates with phi (3), theta (4), p (9), and r (11)
        A_sec(5, 3) = (sec_phi * tan_phi * sin_theta * x9) + (cos_theta * sec_phi * tan_phi * x11); //df5 / d(phi)
        A_sec(5, 4) = (sec_phi * x9 * cos_theta) + (-sin_theta * sec_phi * x11);                    //df5 / d(theta)
        A_sec(5, 9) = (sin_theta / cos_phi);                                                        //df5 / d(p)
        A_sec(5, 11) = (cos_theta / cos_phi);                                                       //df5 / d(r)

        //dx(6) relates with phi (3), theta (4), and psi (5) 
        //dx(6) also relies on values: u0, v0, and m
        A_sec(6, 3) = (u0 + v0) * cos_theta * sin_psi * cos_phi / m;
        A_sec(6, 4) = ((u0 + v0) / m) * ((cos_psi * cos_theta) - (sin_theta * sin_phi * sin_psi));
        A_sec(6, 5) = ((u0 + v0) / m) * ((sin_phi * cos_theta * cos_psi) - (sin_theta * sin_psi));

        //dx(7) relates with phi (3), theta (4), and psi (5) 
        //dx(7) also relies on values: u0, v0, and m
        A_sec(7, 3) = (-(u0 + v0) / m) * cos_phi * cos_psi * cos_theta;
        A_sec(7, 4) = ((u0 + v0) / m) * ((sin_psi * cos_theta) + (cos_psi * sin_theta * sin_phi));
        A_sec(7, 5) = ((u0 + v0) / m) * ((cos_psi * sin_theta) + (sin_psi * cos_theta * sin_phi));

        //dx(8) relates with phi (3), and theta (4)
        //dx(8) also relies on values: u0, v0, and m
        A_sec(8, 3) = -((u0 + v0) / m) * (sin_phi * cos_theta);
        A_sec(8, 4) = -((u0 + v0) / m) * (cos_phi * sin_theta);
/*
        //Remapped old way
        A_sec(6,3)=((u0 + v0)*(-(cos_psi*sin_phi*sin_theta) + cos_phi*sin_psi))/m;
        A_sec(6,4)=((u0 + v0)*cos_phi*cos_theta*cos_psi)/m;
        A_sec(6,5)=((u0 + v0)*(cos_psi*sin_phi - cos_phi*sin_theta*sin_psi))/m;
        A_sec(7,3)=-(((u0 + v0)*(cos_phi*cos_psi + sin_phi*sin_theta*sin_psi))/m);
        A_sec(7,4)=((u0 + v0)*cos_phi*cos_theta*sin_psi)/m;
        A_sec(7,5)=((u0 + v0)*(cos_phi*cos_psi*sin_theta + sin_phi*sin_psi))/m;
        A_sec(8,3)=-(((u0 + v0)*cos_theta*sin_phi)/m);
        A_sec(8,4)=-(((u0 + v0)*cos_phi*sin_theta)/m);
        A_sec(3,3) =(x10*cos_phi - x11*sin_phi)*tan_theta;
        A_sec(3,4) =pow(sec_theta,2)*(x11*cos_phi + x10*sin_phi);
        A_sec(3,9) =1;
        A_sec(3,10)=sin_phi*tan_theta;
        A_sec(3,11)=cos_phi*tan_theta;
        A_sec(4,3) =-(x11*cos_phi) - x10*sin_phi;
        A_sec(4,10)=cos_phi;
        A_sec(4,11)=-sin_phi;
        A_sec(5,3) =sec_theta*(x10*cos_phi - x11*sin_phi);
        A_sec(5,4) =sec_theta*(x11*cos_phi + x10*sin_phi)*tan_theta;
        A_sec(5,10)=sec_theta*sin_phi;
        A_sec(5,11)=cos_phi*sec_theta;
  */
        A_sec(9,10)=((Iyy - Izz)*x11)/Ixx;
        A_sec(9,11)=((Iyy - Izz)*x10)/Ixx;
        A_sec(10,9)=((-Ixx + Izz)*x11)/Iyy;
        A_sec(10,11)=((-Ixx + Izz)*x9)/Iyy;
        A_sec(11,9)=((Ixx - Iyy)*x10)/Izz;
        A_sec(11,10)=((Ixx - Iyy)*x9)/Izz;
      
        ////B_sec(3,0)=(cos_phi*cos_psi*sin_theta + sin_phi*sin_psi)/m;
        ////B_sec(4,0)=(-(cos_psi*sin_phi) + cos_phi*sin_theta*sin_psi)/m;
        ////B_sec(5,0)=(cos_phi*cos_theta)/m;
        //B_sec(6,0)=(cos_phi*cos_psi*sin_theta + sin_phi*sin_psi)/m;
        //B_sec(7,0)=(-(cos_psi*sin_phi) + cos_phi*sin_theta*sin_psi)/m;
        //B_sec(8,0)=(cos_phi*cos_theta)/m;
        
        //B_sec(9,1)=1/Ixx;
        //B_sec(10,2)=1/Iyy;
        //B_sec(11,3)=1/Izz;
        
        ////C_sec(3,0)=(cos_phi*cos_psi*sin_theta + sin_phi*sin_psi)/m;
        ////C_sec(4,0)=(-(cos_psi*sin_phi) + cos_phi*sin_theta*sin_psi)/m;
        ////C_sec(5,0)=(cos_phi*cos_theta)/m;
        //C_sec(6,0)=(cos_phi*cos_psi*sin_theta + sin_phi*sin_psi)/m;
        //C_sec(7,0)=(-(cos_psi*sin_phi) + cos_phi*sin_theta*sin_psi)/m;
        //C_sec(8,0)=(cos_phi*cos_theta)/m;
        
        //C_sec(9,1)=1/Ixx;
        //C_sec(10,2)=1/Iyy;
        //C_sec(11,3)=1/Izz;
        
        A[i]=A_sec;
        B[i]=B_sec;
        C[i]=C_sec;
        
    } //for (int i)
}// linearize_dynamics




